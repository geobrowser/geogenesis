import { SystemIds } from '@graphprotocol/grc-20';
import { atom, useAtom } from 'jotai';
import { atomFamily } from 'jotai/utils';

import * as React from 'react';

import { useEntitySchema } from '../state/entity-page-store/entity-store';
import { useRelations, useValues } from '../sync/use-store';
import { DataType, Property, Relation, RenderableProperty, Value } from '../v2.types';
import { useProperties } from './use-properties';

const SKIPPED_PROPERTIES: string[] = [SystemIds.BLOCKS];

export function useRenderedProperties(entityId: string, spaceId: string) {
  const values = useValues({
    selector: v => v.spaceId === spaceId && v.entity.id === entityId,
  });

  const relations = useRelations({
    selector: r => r.fromEntity.id === entityId && r.spaceId === spaceId,
  });

  const uniqueProperties = new Set(
    [...values.map(v => v.property.id), ...relations.map(r => r.type.id)].filter(p => !SKIPPED_PROPERTIES.includes(p))
  );

  return useProperties([...uniqueProperties.values()]) ?? {};
}

export function usePlaceholderProperties(entityId: string, spaceId: string) {
  const schema = useEntitySchema(entityId, spaceId);
  const map: Record<string, Property> = {};

  for (const p of schema) {
    map[p.id] = p;
  }

  return map;
}

const placeholderRenderablesAtomFamily = atomFamily(
  (entityId: string) => atom<RenderableProperty[]>([]),
  (a, b) => a === b
);

/**
 * Placeholders should be generated by creating empty data, or
 * as derived from an entity's schema.
 *
 * Additionally, we shouldn't return renderables from here. Can
 * solve that afterwards.
 */

export function usePlaceholderRenderables(entityId: string) {
  const [placeholderRenderables, setPlaceholderRenderables] = useAtom(placeholderRenderablesAtomFamily(entityId));

  const onAddPlaceholderRenderable = (renderable: RenderableProperty) => {
    const newPlaceholders = placeholderRenderables.filter(r => r.propertyId !== renderable.propertyId);
    setPlaceholderRenderables([...newPlaceholders, renderable]);
  };

  const onRemoveEmptyPlaceholderRenderable = (renderable: RenderableProperty) => {
    const newPlaceholders = placeholderRenderables.filter(r => r.propertyId !== renderable.propertyId);
    setPlaceholderRenderables([...newPlaceholders]);
  };

  return {
    placeholderRenderables,
    addPlaceholderRenderable: onAddPlaceholderRenderable,
    removeEmptyPlaceholderRenderable: onRemoveEmptyPlaceholderRenderable,
  };
}

export function usePlaceholderRenderables_V2(entityId: string) {
  const [placeholders, setPlaceholders] = React.useState<Record<string, Value | Relation>>({});

  const onAddPlaceholderRenderable = (placeholdersToAdd: { propertyId: string; dataType: DataType }[]) => {
    const newPlaceholders = placeholders;

    for (const newPlaceholder of placeholdersToAdd) {
      if (newPlaceholder.dataType === 'RELATION') {
        // ... Add placeholder relation
      } else {
        // ... Add placeholder value
      }
    }

    setPlaceholders(newPlaceholders);
  };

  const getPlaceholder = (propertyId: string, dataType: DataType) => {
    const placeholder = placeholders[propertyId];

    if (placeholder) {
      if (dataType === 'RELATION') {
        return isRelation(placeholder) ? placeholder : null;
      }

      return isValue(placeholder) ? placeholder : null;
    }

    return null;
  };

  return {
    placeholders,
    addPlaceholder: onAddPlaceholderRenderable,
    getPlaceholder,
  };
}

function isValue(value: Relation | Value): value is Value {
  return 'value' in value;
}

function isRelation(relation: Relation | Value): relation is Relation {
  return 'fromEntity' in relation;
}

export function sortRenderables(renderables: RenderableProperty[], isRelationPage?: boolean) {
  /* Visible triples includes both real triples and placeholder triples */
  return renderables.sort((renderableA, renderableB) => {
    // Always put an empty, placeholder triple with no attribute id at the bottom
    // of the list
    if (renderableA.propertyId === '') return 1;

    const { propertyId: propertyIdA, propertyName: propertyNameA } = renderableA;
    const { propertyId: propertyIdB, propertyName: propertyNameB } = renderableB;

    const isNameA = propertyIdA === SystemIds.NAME_PROPERTY;
    const isNameB = propertyIdB === SystemIds.NAME_PROPERTY;
    const isDescriptionA = propertyIdA === SystemIds.DESCRIPTION_PROPERTY;
    const isDescriptionB = propertyIdB === SystemIds.DESCRIPTION_PROPERTY;
    const isTypesA = propertyIdA === SystemIds.TYPES_PROPERTY;
    const isTypesB = propertyIdB === SystemIds.TYPES_PROPERTY;

    if (isRelationPage) {
      const isRelationTypeA = propertyIdA === SystemIds.RELATION_TYPE_PROPERTY;
      const isRelationTypeB = propertyIdB === SystemIds.RELATION_TYPE_PROPERTY;

      const isRelationFromA = propertyIdA === SystemIds.RELATION_FROM_PROPERTY;
      const isRelationFromB = propertyIdB === SystemIds.RELATION_FROM_PROPERTY;

      const isRelationToA = propertyIdA === SystemIds.RELATION_TO_PROPERTY;
      const isRelationToB = propertyIdB === SystemIds.RELATION_TO_PROPERTY;

      const isRelationIndexA = propertyIdA === SystemIds.RELATION_INDEX;
      const isRelationIndexB = propertyIdB === SystemIds.RELATION_INDEX;

      if (isRelationTypeA && !isRelationTypeB) return -1;
      if (!isRelationTypeA && isRelationTypeB) return 1;

      if (isRelationFromA && !isRelationFromB) return -1;
      if (!isRelationFromA && isRelationFromB) return 1;

      if (isRelationToA && !isRelationToB) return -1;
      if (!isRelationToA && isRelationToB) return 1;

      if (isRelationIndexA && !isRelationIndexB) return 1;
    }

    if (isNameA && !isNameB) return -1;
    if (!isNameA && isNameB) return 1;

    if (isDescriptionA && !isDescriptionB) return -1;
    if (!isDescriptionA && isDescriptionB) return 1;

    if (isTypesA && !isTypesB) return -1;
    if (!isTypesA && isTypesB) return 1;

    return (propertyNameA || '').localeCompare(propertyNameB || '');
  });
}

export function useEditableProperties(entityId: string, spaceId: string) {
  const renderedProperties = useRenderedProperties(entityId, spaceId);
  const placeholderProperties = usePlaceholderProperties(entityId, spaceId);

  const properties: Record<string, Property> = {};

  for (const p of [...Object.values(placeholderProperties)]) {
    properties[p.id] = p;
  }

  for (const p of [...Object.values(renderedProperties)]) {
    properties[p.id] = p;
  }

  return properties;
}
