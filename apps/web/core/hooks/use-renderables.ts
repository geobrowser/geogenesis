'use client';

import { SystemIds } from '@geoprotocol/geo-sdk';

import * as React from 'react';

import { useEntitySchema } from '../state/entity-page-store/entity-store';
import { useRelations, useValues } from '../sync/use-store';
import { DataType, Property, Relation, Value } from '../types';
import { sortProperties, useProperties } from './use-properties';

const SKIPPED_PROPERTIES: string[] = [SystemIds.BLOCKS];

export function useRenderedProperties(entityId: string, spaceId: string) {
  const values = useValues({
    selector: v => v.spaceId === spaceId && v.entity.id === entityId,
  });

  const relations = useRelations({
    selector: r => r.fromEntity.id === entityId && r.spaceId === spaceId,
  });

  const uniqueProperties = new Set(
    [...values.map(v => v.property.id), ...relations.map(r => r.type.id)].filter(p => !SKIPPED_PROPERTIES.includes(p))
  );

  return useProperties([...uniqueProperties.values()]) ?? {};
}

/**
 * Returns only properties that have actual non-empty content (non-empty values or relations).
 * Use this for view/browse mode where empty properties should not be displayed.
 */
export function useRenderedPropertiesWithContent(entityId: string, spaceId: string) {
  const values = useValues({
    selector: v => v.spaceId === spaceId && v.entity.id === entityId,
  });

  const relations = useRelations({
    selector: r => r.fromEntity.id === entityId && r.spaceId === spaceId,
  });

  // Filter out empty values - only include properties with actual content
  const nonEmptyValues = values.filter(v => v.value);

  const uniqueProperties = new Set(
    [...nonEmptyValues.map(v => v.property.id), ...relations.map(r => r.type.id)].filter(p => !SKIPPED_PROPERTIES.includes(p))
  );

  return useProperties([...uniqueProperties.values()]) ?? {};
}

export function usePlaceholderProperties(entityId: string, spaceId: string) {
  const schema = useEntitySchema(entityId, spaceId);
  const map: Record<string, Property> = {};

  for (const p of schema) {
    map[p.id] = p;
  }

  return map;
}

/**
 * Placeholders should be generated by creating empty data, or
 * as derived from an entity's schema.
 *
 * Additionally, we shouldn't return renderables from here. Can
 * solve that afterwards.
 */

export function usePlaceholderRenderables_V2(entityId: string) {
  const [placeholders, setPlaceholders] = React.useState<Record<string, Value | Relation>>({});

  const onAddPlaceholderRenderable = (placeholdersToAdd: { propertyId: string; dataType: DataType }[]) => {
    const newPlaceholders = placeholders;

    for (const newPlaceholder of placeholdersToAdd) {
      if (newPlaceholder.dataType === 'RELATION') {
        // ... Add placeholder relation
      } else {
        // ... Add placeholder value
      }
    }

    setPlaceholders(newPlaceholders);
  };

  const getPlaceholder = (propertyId: string, dataType: DataType) => {
    const placeholder = placeholders[propertyId];

    if (placeholder) {
      if (dataType === 'RELATION') {
        return isRelation(placeholder) ? placeholder : null;
      }

      return isValue(placeholder) ? placeholder : null;
    }

    return null;
  };

  return {
    placeholders,
    addPlaceholder: onAddPlaceholderRenderable,
    getPlaceholder,
  };
}

function isValue(value: Relation | Value): value is Value {
  return 'value' in value;
}

function isRelation(relation: Relation | Value): relation is Relation {
  return 'fromEntity' in relation;
}

export function useEditableProperties(entityId: string, spaceId: string) {
  const renderedProperties = useRenderedProperties(entityId, spaceId);
  const placeholderProperties = usePlaceholderProperties(entityId, spaceId);

  const allProperties = [...Object.values(placeholderProperties), ...Object.values(renderedProperties)];

  // Apply the same sorting logic used in useProperties to ensure consistent order
  const sortedProperties = sortProperties(allProperties);

  const properties: Record<string, Property> = {};
  for (const p of sortedProperties) {
    properties[p.id] = p;
  }

  return properties;
}
