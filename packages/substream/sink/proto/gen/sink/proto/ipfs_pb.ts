// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file sink/proto/ipfs.proto (syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @TODO: Should be called something else?
 *
 * @generated from enum ActionType
 */
export enum ActionType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: ADD_EDIT = 1;
   */
  ADD_EDIT = 1,

  /**
   * @generated from enum value: IMPORT_SPACE = 2;
   */
  IMPORT_SPACE = 2,

  /**
   * @generated from enum value: ADD_SUBSPACE = 3;
   */
  ADD_SUBSPACE = 3,

  /**
   * @generated from enum value: REMOVE_SUBSPACE = 4;
   */
  REMOVE_SUBSPACE = 4,

  /**
   * @generated from enum value: ADD_EDITOR = 5;
   */
  ADD_EDITOR = 5,

  /**
   * @generated from enum value: REMOVE_EDITOR = 6;
   */
  REMOVE_EDITOR = 6,

  /**
   * @generated from enum value: ADD_MEMBER = 7;
   */
  ADD_MEMBER = 7,

  /**
   * @generated from enum value: REMOVE_MEMBER = 8;
   */
  REMOVE_MEMBER = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(ActionType)
proto3.util.setEnumType(ActionType, "ActionType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "ADD_EDIT" },
  { no: 2, name: "IMPORT_SPACE" },
  { no: 3, name: "ADD_SUBSPACE" },
  { no: 4, name: "REMOVE_SUBSPACE" },
  { no: 5, name: "ADD_EDITOR" },
  { no: 6, name: "REMOVE_EDITOR" },
  { no: 7, name: "ADD_MEMBER" },
  { no: 8, name: "REMOVE_MEMBER" },
]);

/**
 * @generated from enum OpType
 */
export enum OpType {
  /**
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * @generated from enum value: SET_TRIPLE = 1;
   */
  SET_TRIPLE = 1,

  /**
   * @generated from enum value: DELETE_TRIPLE = 2;
   */
  DELETE_TRIPLE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(OpType)
proto3.util.setEnumType(OpType, "OpType", [
  { no: 0, name: "NONE" },
  { no: 1, name: "SET_TRIPLE" },
  { no: 2, name: "DELETE_TRIPLE" },
]);

/**
 * @generated from enum ValueType
 */
export enum ValueType {
  /**
   * @generated from enum value: NULL = 0;
   */
  NULL = 0,

  /**
   * @generated from enum value: TEXT = 1;
   */
  TEXT = 1,

  /**
   * @generated from enum value: NUMBER = 2;
   */
  NUMBER = 2,

  /**
   * @generated from enum value: ENTITY = 3;
   */
  ENTITY = 3,

  /**
   * @generated from enum value: COLLECTION = 4;
   */
  COLLECTION = 4,

  /**
   * @generated from enum value: CHECKBOX = 5;
   */
  CHECKBOX = 5,

  /**
   * @generated from enum value: URL = 6;
   */
  URL = 6,

  /**
   * @generated from enum value: TIME = 7;
   */
  TIME = 7,

  /**
   * @generated from enum value: GEO_LOCATION = 8;
   */
  GEO_LOCATION = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(ValueType)
proto3.util.setEnumType(ValueType, "ValueType", [
  { no: 0, name: "NULL" },
  { no: 1, name: "TEXT" },
  { no: 2, name: "NUMBER" },
  { no: 3, name: "ENTITY" },
  { no: 4, name: "COLLECTION" },
  { no: 5, name: "CHECKBOX" },
  { no: 6, name: "URL" },
  { no: 7, name: "TIME" },
  { no: 8, name: "GEO_LOCATION" },
]);

/**
 * @generated from message IpfsMetadata
 */
export class IpfsMetadata extends Message<IpfsMetadata> {
  /**
   * We version the data structured used to represent proposal metadata. Each
   * proposal type has their own metadata and versioning that we can change
   * independently of other proposal types.
   *
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * @generated from field: ActionType type = 2;
   */
  type = ActionType.UNKNOWN;

  /**
   * @generated from field: string id = 3;
   */
  id = "";

  /**
   * @generated from field: string name = 4;
   */
  name = "";

  constructor(data?: PartialMessage<IpfsMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "IpfsMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(ActionType) },
    { no: 3, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IpfsMetadata {
    return new IpfsMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IpfsMetadata {
    return new IpfsMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IpfsMetadata {
    return new IpfsMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: IpfsMetadata | PlainMessage<IpfsMetadata> | undefined, b: IpfsMetadata | PlainMessage<IpfsMetadata> | undefined): boolean {
    return proto3.util.equals(IpfsMetadata, a, b);
  }
}

/**
 * @generated from message Edit
 */
export class Edit extends Message<Edit> {
  /**
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * @generated from field: ActionType type = 2;
   */
  type = ActionType.UNKNOWN;

  /**
   * @generated from field: string id = 3;
   */
  id = "";

  /**
   * @generated from field: string name = 4;
   */
  name = "";

  /**
   * @generated from field: repeated Op ops = 5;
   */
  ops: Op[] = [];

  /**
   * @generated from field: repeated string authors = 6;
   */
  authors: string[] = [];

  constructor(data?: PartialMessage<Edit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Edit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(ActionType) },
    { no: 3, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "ops", kind: "message", T: Op, repeated: true },
    { no: 6, name: "authors", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Edit {
    return new Edit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Edit {
    return new Edit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Edit {
    return new Edit().fromJsonString(jsonString, options);
  }

  static equals(a: Edit | PlainMessage<Edit> | undefined, b: Edit | PlainMessage<Edit> | undefined): boolean {
    return proto3.util.equals(Edit, a, b);
  }
}

/**
 * @generated from message Op
 */
export class Op extends Message<Op> {
  /**
   * @generated from field: OpType opType = 1;
   */
  opType = OpType.NONE;

  /**
   * @generated from field: Payload payload = 2;
   */
  payload?: Payload;

  constructor(data?: PartialMessage<Op>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Op";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "opType", kind: "enum", T: proto3.getEnumType(OpType) },
    { no: 2, name: "payload", kind: "message", T: Payload },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Op {
    return new Op().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Op {
    return new Op().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Op {
    return new Op().fromJsonString(jsonString, options);
  }

  static equals(a: Op | PlainMessage<Op> | undefined, b: Op | PlainMessage<Op> | undefined): boolean {
    return proto3.util.equals(Op, a, b);
  }
}

/**
 * @generated from message Payload
 */
export class Payload extends Message<Payload> {
  /**
   * @generated from field: bytes entityId = 1;
   */
  entityId = new Uint8Array(0);

  /**
   * @generated from field: bytes attributeId = 2;
   */
  attributeId = new Uint8Array(0);

  /**
   * @generated from field: Value value = 3;
   */
  value?: Value;

  constructor(data?: PartialMessage<Payload>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Payload";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entityId", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "attributeId", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "value", kind: "message", T: Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Payload {
    return new Payload().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Payload {
    return new Payload().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Payload {
    return new Payload().fromJsonString(jsonString, options);
  }

  static equals(a: Payload | PlainMessage<Payload> | undefined, b: Payload | PlainMessage<Payload> | undefined): boolean {
    return proto3.util.equals(Payload, a, b);
  }
}

/**
 * @generated from message Value
 */
export class Value extends Message<Value> {
  /**
   * @generated from field: ValueType type = 1;
   */
  type = ValueType.NULL;

  /**
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<Value>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Value";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(ValueType) },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Value {
    return new Value().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJsonString(jsonString, options);
  }

  static equals(a: Value | PlainMessage<Value> | undefined, b: Value | PlainMessage<Value> | undefined): boolean {
    return proto3.util.equals(Value, a, b);
  }
}

/**
 * @generated from message Membership
 */
export class Membership extends Message<Membership> {
  /**
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * @generated from field: ActionType type = 2;
   */
  type = ActionType.UNKNOWN;

  /**
   * @generated from field: string id = 3;
   */
  id = "";

  /**
   * @generated from field: string name = 4;
   */
  name = "";

  /**
   * @generated from field: string userAddress = 5;
   */
  userAddress = "";

  constructor(data?: PartialMessage<Membership>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Membership";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(ActionType) },
    { no: 3, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "userAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Membership {
    return new Membership().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Membership {
    return new Membership().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Membership {
    return new Membership().fromJsonString(jsonString, options);
  }

  static equals(a: Membership | PlainMessage<Membership> | undefined, b: Membership | PlainMessage<Membership> | undefined): boolean {
    return proto3.util.equals(Membership, a, b);
  }
}

/**
 * @generated from message Subspace
 */
export class Subspace extends Message<Subspace> {
  /**
   * @generated from field: string version = 1;
   */
  version = "";

  /**
   * @generated from field: ActionType type = 2;
   */
  type = ActionType.UNKNOWN;

  /**
   * @generated from field: string id = 3;
   */
  id = "";

  /**
   * @generated from field: string name = 4;
   */
  name = "";

  /**
   * @generated from field: string subspace = 5;
   */
  subspace = "";

  constructor(data?: PartialMessage<Subspace>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Subspace";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(ActionType) },
    { no: 3, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "subspace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Subspace {
    return new Subspace().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Subspace {
    return new Subspace().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Subspace {
    return new Subspace().fromJsonString(jsonString, options);
  }

  static equals(a: Subspace | PlainMessage<Subspace> | undefined, b: Subspace | PlainMessage<Subspace> | undefined): boolean {
    return proto3.util.equals(Subspace, a, b);
  }
}

/**
 * @generated from message Import
 */
export class Import extends Message<Import> {
  /**
   * @generated from field: string previousNetwork = 1;
   */
  previousNetwork = "";

  /**
   * @generated from field: string previousContractAddress = 2;
   */
  previousContractAddress = "";

  /**
   * @generated from field: repeated string edits = 3;
   */
  edits: string[] = [];

  constructor(data?: PartialMessage<Import>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "Import";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "previousNetwork", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "previousContractAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "edits", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Import {
    return new Import().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Import {
    return new Import().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Import {
    return new Import().fromJsonString(jsonString, options);
  }

  static equals(a: Import | PlainMessage<Import> | undefined, b: Import | PlainMessage<Import> | undefined): boolean {
    return proto3.util.equals(Import, a, b);
  }
}

