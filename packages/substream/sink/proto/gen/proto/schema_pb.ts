// @generated by protoc-gen-es v1.9.0 with parameter "target=ts"
// @generated from file proto/schema.proto (package schema, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * *
 * Profiles represent the users of Geo. Profiles are registered in the GeoProfileRegistry
 * contract and are associated with a user's EVM-based address and the space where metadata
 * representing their profile resides in.
 *
 * @generated from message schema.GeoProfileRegistered
 */
export class GeoProfileRegistered extends Message<GeoProfileRegistered> {
  /**
   * @generated from field: string requestor = 1;
   */
  requestor = "";

  /**
   * @generated from field: string space = 2;
   */
  space = "";

  /**
   * @generated from field: string id = 3;
   */
  id = "";

  constructor(data?: PartialMessage<GeoProfileRegistered>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.GeoProfileRegistered";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requestor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "space", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoProfileRegistered {
    return new GeoProfileRegistered().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoProfileRegistered {
    return new GeoProfileRegistered().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoProfileRegistered {
    return new GeoProfileRegistered().fromJsonString(jsonString, options);
  }

  static equals(a: GeoProfileRegistered | PlainMessage<GeoProfileRegistered> | undefined, b: GeoProfileRegistered | PlainMessage<GeoProfileRegistered> | undefined): boolean {
    return proto3.util.equals(GeoProfileRegistered, a, b);
  }
}

/**
 * @generated from message schema.GeoProfilesRegistered
 */
export class GeoProfilesRegistered extends Message<GeoProfilesRegistered> {
  /**
   * @generated from field: repeated schema.GeoProfileRegistered profiles = 1;
   */
  profiles: GeoProfileRegistered[] = [];

  constructor(data?: PartialMessage<GeoProfilesRegistered>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.GeoProfilesRegistered";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "profiles", kind: "message", T: GeoProfileRegistered, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoProfilesRegistered {
    return new GeoProfilesRegistered().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoProfilesRegistered {
    return new GeoProfilesRegistered().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoProfilesRegistered {
    return new GeoProfilesRegistered().fromJsonString(jsonString, options);
  }

  static equals(a: GeoProfilesRegistered | PlainMessage<GeoProfilesRegistered> | undefined, b: GeoProfilesRegistered | PlainMessage<GeoProfilesRegistered> | undefined): boolean {
    return proto3.util.equals(GeoProfilesRegistered, a, b);
  }
}

/**
 * *
 * The new DAO-based contracts allow forking of spaces into successor spaces. This is so
 * users can create new spaces whose data is derived from another space.
 *
 * This is immediately useful when migrating from legacy spaces to the new DAO-based spaces,
 * but it's generally applicable across any space.
 *
 * @generated from message schema.SuccessorSpaceCreated
 */
export class SuccessorSpaceCreated extends Message<SuccessorSpaceCreated> {
  /**
   * @generated from field: string predecessorSpace = 1;
   */
  predecessorSpace = "";

  /**
   * @generated from field: string pluginAddress = 2;
   */
  pluginAddress = "";

  constructor(data?: PartialMessage<SuccessorSpaceCreated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.SuccessorSpaceCreated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predecessorSpace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pluginAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SuccessorSpaceCreated {
    return new SuccessorSpaceCreated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SuccessorSpaceCreated {
    return new SuccessorSpaceCreated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SuccessorSpaceCreated {
    return new SuccessorSpaceCreated().fromJsonString(jsonString, options);
  }

  static equals(a: SuccessorSpaceCreated | PlainMessage<SuccessorSpaceCreated> | undefined, b: SuccessorSpaceCreated | PlainMessage<SuccessorSpaceCreated> | undefined): boolean {
    return proto3.util.equals(SuccessorSpaceCreated, a, b);
  }
}

/**
 * @generated from message schema.SuccessorSpacesCreated
 */
export class SuccessorSpacesCreated extends Message<SuccessorSpacesCreated> {
  /**
   * @generated from field: repeated schema.SuccessorSpaceCreated spaces = 1;
   */
  spaces: SuccessorSpaceCreated[] = [];

  constructor(data?: PartialMessage<SuccessorSpacesCreated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.SuccessorSpacesCreated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spaces", kind: "message", T: SuccessorSpaceCreated, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SuccessorSpacesCreated {
    return new SuccessorSpacesCreated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SuccessorSpacesCreated {
    return new SuccessorSpacesCreated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SuccessorSpacesCreated {
    return new SuccessorSpacesCreated().fromJsonString(jsonString, options);
  }

  static equals(a: SuccessorSpacesCreated | PlainMessage<SuccessorSpacesCreated> | undefined, b: SuccessorSpacesCreated | PlainMessage<SuccessorSpacesCreated> | undefined): boolean {
    return proto3.util.equals(SuccessorSpacesCreated, a, b);
  }
}

/**
 * *
 * The new DAO-based space contracts are based on Aragon's OSX architecture which uses
 * plugins to define functionality assigned to a DAO (See the top level comment for more
 * information on Aragon's DAO architecture).
 *
 * This event maps creation of the Space plugin and associates the Space plugin contract
 * address with the address of the DAO contract.
 *
 * @generated from message schema.GeoSpaceCreated
 */
export class GeoSpaceCreated extends Message<GeoSpaceCreated> {
  /**
   * @generated from field: string daoAddress = 1;
   */
  daoAddress = "";

  /**
   * @generated from field: string spaceAddress = 2;
   */
  spaceAddress = "";

  constructor(data?: PartialMessage<GeoSpaceCreated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.GeoSpaceCreated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "daoAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "spaceAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoSpaceCreated {
    return new GeoSpaceCreated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoSpaceCreated {
    return new GeoSpaceCreated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoSpaceCreated {
    return new GeoSpaceCreated().fromJsonString(jsonString, options);
  }

  static equals(a: GeoSpaceCreated | PlainMessage<GeoSpaceCreated> | undefined, b: GeoSpaceCreated | PlainMessage<GeoSpaceCreated> | undefined): boolean {
    return proto3.util.equals(GeoSpaceCreated, a, b);
  }
}

/**
 * @generated from message schema.GeoSpacesCreated
 */
export class GeoSpacesCreated extends Message<GeoSpacesCreated> {
  /**
   * @generated from field: repeated schema.GeoSpaceCreated spaces = 1;
   */
  spaces: GeoSpaceCreated[] = [];

  constructor(data?: PartialMessage<GeoSpacesCreated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.GeoSpacesCreated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spaces", kind: "message", T: GeoSpaceCreated, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoSpacesCreated {
    return new GeoSpacesCreated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoSpacesCreated {
    return new GeoSpacesCreated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoSpacesCreated {
    return new GeoSpacesCreated().fromJsonString(jsonString, options);
  }

  static equals(a: GeoSpacesCreated | PlainMessage<GeoSpacesCreated> | undefined, b: GeoSpacesCreated | PlainMessage<GeoSpacesCreated> | undefined): boolean {
    return proto3.util.equals(GeoSpacesCreated, a, b);
  }
}

/**
 * *
 * The new DAO-based space contracts are based on Aragon's OSX architecture which uses
 * plugins to define functionality assigned to a DAO (See the top level comment for more
 * information on Aragon's DAO architecture).
 *
 * This event maps creation of any governance plugins and associates the governance plugins
 * contract addresses with the address of the DAO contract.
 *
 * As of January 23, 2024 there are two governance plugins:
 * 1. Voting plugin – This defines the voting and proposal rules and behaviors for a DAO
 * 2. Member access plugin – This defines the membership rules and behaviors for a DAO
 *
 * @generated from message schema.GeoGovernancePluginCreated
 */
export class GeoGovernancePluginCreated extends Message<GeoGovernancePluginCreated> {
  /**
   * @generated from field: string daoAddress = 1;
   */
  daoAddress = "";

  /**
   * @generated from field: string mainVotingAddress = 2;
   */
  mainVotingAddress = "";

  /**
   * @generated from field: string memberAccessAddress = 3;
   */
  memberAccessAddress = "";

  constructor(data?: PartialMessage<GeoGovernancePluginCreated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.GeoGovernancePluginCreated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "daoAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mainVotingAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "memberAccessAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoGovernancePluginCreated {
    return new GeoGovernancePluginCreated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoGovernancePluginCreated {
    return new GeoGovernancePluginCreated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoGovernancePluginCreated {
    return new GeoGovernancePluginCreated().fromJsonString(jsonString, options);
  }

  static equals(a: GeoGovernancePluginCreated | PlainMessage<GeoGovernancePluginCreated> | undefined, b: GeoGovernancePluginCreated | PlainMessage<GeoGovernancePluginCreated> | undefined): boolean {
    return proto3.util.equals(GeoGovernancePluginCreated, a, b);
  }
}

/**
 * @generated from message schema.GeoGovernancePluginsCreated
 */
export class GeoGovernancePluginsCreated extends Message<GeoGovernancePluginsCreated> {
  /**
   * @generated from field: repeated schema.GeoGovernancePluginCreated plugins = 1;
   */
  plugins: GeoGovernancePluginCreated[] = [];

  constructor(data?: PartialMessage<GeoGovernancePluginsCreated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.GeoGovernancePluginsCreated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "plugins", kind: "message", T: GeoGovernancePluginCreated, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoGovernancePluginsCreated {
    return new GeoGovernancePluginsCreated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoGovernancePluginsCreated {
    return new GeoGovernancePluginsCreated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoGovernancePluginsCreated {
    return new GeoGovernancePluginsCreated().fromJsonString(jsonString, options);
  }

  static equals(a: GeoGovernancePluginsCreated | PlainMessage<GeoGovernancePluginsCreated> | undefined, b: GeoGovernancePluginsCreated | PlainMessage<GeoGovernancePluginsCreated> | undefined): boolean {
    return proto3.util.equals(GeoGovernancePluginsCreated, a, b);
  }
}

/**
 * @generated from message schema.GeoPersonalSpaceAdminPluginCreated
 */
export class GeoPersonalSpaceAdminPluginCreated extends Message<GeoPersonalSpaceAdminPluginCreated> {
  /**
   * @generated from field: string daoAddress = 1;
   */
  daoAddress = "";

  /**
   * @generated from field: string personalAdminAddress = 2;
   */
  personalAdminAddress = "";

  /**
   * @generated from field: string initialEditor = 3;
   */
  initialEditor = "";

  constructor(data?: PartialMessage<GeoPersonalSpaceAdminPluginCreated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.GeoPersonalSpaceAdminPluginCreated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "daoAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "personalAdminAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "initialEditor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoPersonalSpaceAdminPluginCreated {
    return new GeoPersonalSpaceAdminPluginCreated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoPersonalSpaceAdminPluginCreated {
    return new GeoPersonalSpaceAdminPluginCreated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoPersonalSpaceAdminPluginCreated {
    return new GeoPersonalSpaceAdminPluginCreated().fromJsonString(jsonString, options);
  }

  static equals(a: GeoPersonalSpaceAdminPluginCreated | PlainMessage<GeoPersonalSpaceAdminPluginCreated> | undefined, b: GeoPersonalSpaceAdminPluginCreated | PlainMessage<GeoPersonalSpaceAdminPluginCreated> | undefined): boolean {
    return proto3.util.equals(GeoPersonalSpaceAdminPluginCreated, a, b);
  }
}

/**
 * @generated from message schema.GeoPersonalSpaceAdminPluginsCreated
 */
export class GeoPersonalSpaceAdminPluginsCreated extends Message<GeoPersonalSpaceAdminPluginsCreated> {
  /**
   * @generated from field: repeated schema.GeoPersonalSpaceAdminPluginCreated plugins = 1;
   */
  plugins: GeoPersonalSpaceAdminPluginCreated[] = [];

  constructor(data?: PartialMessage<GeoPersonalSpaceAdminPluginsCreated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.GeoPersonalSpaceAdminPluginsCreated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "plugins", kind: "message", T: GeoPersonalSpaceAdminPluginCreated, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoPersonalSpaceAdminPluginsCreated {
    return new GeoPersonalSpaceAdminPluginsCreated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoPersonalSpaceAdminPluginsCreated {
    return new GeoPersonalSpaceAdminPluginsCreated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoPersonalSpaceAdminPluginsCreated {
    return new GeoPersonalSpaceAdminPluginsCreated().fromJsonString(jsonString, options);
  }

  static equals(a: GeoPersonalSpaceAdminPluginsCreated | PlainMessage<GeoPersonalSpaceAdminPluginsCreated> | undefined, b: GeoPersonalSpaceAdminPluginsCreated | PlainMessage<GeoPersonalSpaceAdminPluginsCreated> | undefined): boolean {
    return proto3.util.equals(GeoPersonalSpaceAdminPluginsCreated, a, b);
  }
}

/**
 * *
 * This event represents adding editors to a DAO-based space
 *
 * The data model for DAO-based spaces works slightly differently than in legacy spaces.
 * This means there will be a period where we need to support both data models depending
 * on which space/contract we are working with. Eventually these data models will be merged
 * and usage of the legacy space contracts will be migrated to the DAO-based contracts, but
 * for now we are appending "V2" to permissions data models to denote it's used for the
 * DAO-based spaces.
 *
 * An editor has editing and voting permissions in a DAO-based space. Editors join a space
 * one of two ways:
 * 1. They submit a request to join the space as an editor which goes to a vote. The editors
 *    in the space vote on whether to accept the new editor.
 * 2. They are added as a set of initial editors when first creating the space. This allows
 *    space deployers to bootstrap a set of editors on space creation.
 *
 * @generated from message schema.InitialEditorAdded
 */
export class InitialEditorAdded extends Message<InitialEditorAdded> {
  /**
   * The event emits an array of addresses. We only emit multiple addresses
   * when first creating the governance plugin. After that we only emit one
   * address at a time via proposals.
   *
   * @generated from field: repeated string addresses = 1;
   */
  addresses: string[] = [];

  /**
   * @generated from field: string pluginAddress = 2;
   */
  pluginAddress = "";

  constructor(data?: PartialMessage<InitialEditorAdded>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.InitialEditorAdded";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "pluginAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InitialEditorAdded {
    return new InitialEditorAdded().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InitialEditorAdded {
    return new InitialEditorAdded().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InitialEditorAdded {
    return new InitialEditorAdded().fromJsonString(jsonString, options);
  }

  static equals(a: InitialEditorAdded | PlainMessage<InitialEditorAdded> | undefined, b: InitialEditorAdded | PlainMessage<InitialEditorAdded> | undefined): boolean {
    return proto3.util.equals(InitialEditorAdded, a, b);
  }
}

/**
 * @generated from message schema.InitialEditorsAdded
 */
export class InitialEditorsAdded extends Message<InitialEditorsAdded> {
  /**
   * @generated from field: repeated schema.InitialEditorAdded editors = 1;
   */
  editors: InitialEditorAdded[] = [];

  constructor(data?: PartialMessage<InitialEditorsAdded>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.InitialEditorsAdded";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "editors", kind: "message", T: InitialEditorAdded, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InitialEditorsAdded {
    return new InitialEditorsAdded().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InitialEditorsAdded {
    return new InitialEditorsAdded().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InitialEditorsAdded {
    return new InitialEditorsAdded().fromJsonString(jsonString, options);
  }

  static equals(a: InitialEditorsAdded | PlainMessage<InitialEditorsAdded> | undefined, b: InitialEditorsAdded | PlainMessage<InitialEditorsAdded> | undefined): boolean {
    return proto3.util.equals(InitialEditorsAdded, a, b);
  }
}

/**
 * *
 * Proposals represent a proposal to change the state of a DAO-based space. Proposals can
 * represent changes to content, membership (editor or member), governance changes, subspace
 * membership, or anything else that can be executed by a DAO.
 *
 * Currently we use a simple majority voting model, where a proposal requires 51% of the
 * available votes in order to pass. Only editors are allowed to vote on proposals, but editors
 * _and_ members can create them.
 *
 * Proposals require encoding a "callback" that represents the action to be taken if the proposal
 * succeeds. For example, if a proposal is to add a new editor to the space, the callback would
 * be the encoded function call to add the editor to the space.
 *
 * ```ts
 * {
 *   to: `0x123...`, // The address of the membership contract
 *   data: `0x123...`, // The encoded function call parameters
 * }
 * ```
 *
 * @generated from message schema.DaoAction
 */
export class DaoAction extends Message<DaoAction> {
  /**
   * @generated from field: string to = 1;
   */
  to = "";

  /**
   * @generated from field: uint64 value = 2;
   */
  value = protoInt64.zero;

  /**
   * @generated from field: bytes data = 3;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<DaoAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.DaoAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DaoAction {
    return new DaoAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DaoAction {
    return new DaoAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DaoAction {
    return new DaoAction().fromJsonString(jsonString, options);
  }

  static equals(a: DaoAction | PlainMessage<DaoAction> | undefined, b: DaoAction | PlainMessage<DaoAction> | undefined): boolean {
    return proto3.util.equals(DaoAction, a, b);
  }
}

/**
 * @generated from message schema.ProposalCreated
 */
export class ProposalCreated extends Message<ProposalCreated> {
  /**
   * @generated from field: string proposal_id = 1;
   */
  proposalId = "";

  /**
   * @generated from field: string creator = 2;
   */
  creator = "";

  /**
   * @generated from field: string start_time = 3;
   */
  startTime = "";

  /**
   * @generated from field: string end_time = 4;
   */
  endTime = "";

  /**
   * @generated from field: string metadata_uri = 5;
   */
  metadataUri = "";

  /**
   * @generated from field: string plugin_address = 6;
   */
  pluginAddress = "";

  constructor(data?: PartialMessage<ProposalCreated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.ProposalCreated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposal_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "start_time", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "end_time", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "metadata_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "plugin_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProposalCreated {
    return new ProposalCreated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProposalCreated {
    return new ProposalCreated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProposalCreated {
    return new ProposalCreated().fromJsonString(jsonString, options);
  }

  static equals(a: ProposalCreated | PlainMessage<ProposalCreated> | undefined, b: ProposalCreated | PlainMessage<ProposalCreated> | undefined): boolean {
    return proto3.util.equals(ProposalCreated, a, b);
  }
}

/**
 * @generated from message schema.ProposalsCreated
 */
export class ProposalsCreated extends Message<ProposalsCreated> {
  /**
   * @generated from field: repeated schema.ProposalCreated proposals = 1;
   */
  proposals: ProposalCreated[] = [];

  constructor(data?: PartialMessage<ProposalsCreated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.ProposalsCreated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposals", kind: "message", T: ProposalCreated, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProposalsCreated {
    return new ProposalsCreated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProposalsCreated {
    return new ProposalsCreated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProposalsCreated {
    return new ProposalsCreated().fromJsonString(jsonString, options);
  }

  static equals(a: ProposalsCreated | PlainMessage<ProposalsCreated> | undefined, b: ProposalsCreated | PlainMessage<ProposalsCreated> | undefined): boolean {
    return proto3.util.equals(ProposalsCreated, a, b);
  }
}

/**
 * Executed proposals have been approved and executed onchain in a DAO-based
 * space's main voting plugin. The DAO itself also emits the executed event,
 * but the ABI/interface is different. We really only care about the one
 * from our plugins.
 *
 * @generated from message schema.ProposalExecuted
 */
export class ProposalExecuted extends Message<ProposalExecuted> {
  /**
   * @generated from field: string proposal_id = 1;
   */
  proposalId = "";

  /**
   * @generated from field: string plugin_address = 2;
   */
  pluginAddress = "";

  constructor(data?: PartialMessage<ProposalExecuted>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.ProposalExecuted";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposal_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "plugin_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProposalExecuted {
    return new ProposalExecuted().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProposalExecuted {
    return new ProposalExecuted().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProposalExecuted {
    return new ProposalExecuted().fromJsonString(jsonString, options);
  }

  static equals(a: ProposalExecuted | PlainMessage<ProposalExecuted> | undefined, b: ProposalExecuted | PlainMessage<ProposalExecuted> | undefined): boolean {
    return proto3.util.equals(ProposalExecuted, a, b);
  }
}

/**
 * @generated from message schema.ProposalsExecuted
 */
export class ProposalsExecuted extends Message<ProposalsExecuted> {
  /**
   * @generated from field: repeated schema.ProposalExecuted executed_proposals = 1;
   */
  executedProposals: ProposalExecuted[] = [];

  constructor(data?: PartialMessage<ProposalsExecuted>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.ProposalsExecuted";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "executed_proposals", kind: "message", T: ProposalExecuted, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProposalsExecuted {
    return new ProposalsExecuted().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProposalsExecuted {
    return new ProposalsExecuted().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProposalsExecuted {
    return new ProposalsExecuted().fromJsonString(jsonString, options);
  }

  static equals(a: ProposalsExecuted | PlainMessage<ProposalsExecuted> | undefined, b: ProposalsExecuted | PlainMessage<ProposalsExecuted> | undefined): boolean {
    return proto3.util.equals(ProposalsExecuted, a, b);
  }
}

/**
 * *
 * Processed Proposals represent content that has been approved by a DAO
 * and executed onchain.
 *
 * We use the content URI to represent the content that was approved. We
 * only consume the `proposalId` in the content URI to map the processed
 * data to an existing proposal onchain and in the sink.
 *
 * @generated from message schema.ProposalProcessed
 */
export class ProposalProcessed extends Message<ProposalProcessed> {
  /**
   * @generated from field: string content_uri = 1;
   */
  contentUri = "";

  /**
   * @generated from field: string plugin_address = 2;
   */
  pluginAddress = "";

  constructor(data?: PartialMessage<ProposalProcessed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.ProposalProcessed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "plugin_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProposalProcessed {
    return new ProposalProcessed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProposalProcessed {
    return new ProposalProcessed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProposalProcessed {
    return new ProposalProcessed().fromJsonString(jsonString, options);
  }

  static equals(a: ProposalProcessed | PlainMessage<ProposalProcessed> | undefined, b: ProposalProcessed | PlainMessage<ProposalProcessed> | undefined): boolean {
    return proto3.util.equals(ProposalProcessed, a, b);
  }
}

/**
 * @generated from message schema.ProposalsProcessed
 */
export class ProposalsProcessed extends Message<ProposalsProcessed> {
  /**
   * @generated from field: repeated schema.ProposalProcessed proposals = 1;
   */
  proposals: ProposalProcessed[] = [];

  constructor(data?: PartialMessage<ProposalsProcessed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.ProposalsProcessed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "proposals", kind: "message", T: ProposalProcessed, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProposalsProcessed {
    return new ProposalsProcessed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProposalsProcessed {
    return new ProposalsProcessed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProposalsProcessed {
    return new ProposalsProcessed().fromJsonString(jsonString, options);
  }

  static equals(a: ProposalsProcessed | PlainMessage<ProposalsProcessed> | undefined, b: ProposalsProcessed | PlainMessage<ProposalsProcessed> | undefined): boolean {
    return proto3.util.equals(ProposalsProcessed, a, b);
  }
}

/**
 * *
 * Added or Removed Subspaces represent adding a space contracto to the hierarchy
 * of the DAO-based space. This is useful to "link" Spaces together in a
 * tree of spaces, allowing us to curate the graph of their knowledge and 
 * permissions.
 *
 * @generated from message schema.SubspaceAdded
 */
export class SubspaceAdded extends Message<SubspaceAdded> {
  /**
   * @generated from field: string subspace = 1;
   */
  subspace = "";

  /**
   * @generated from field: string plugin_address = 2;
   */
  pluginAddress = "";

  /**
   * @generated from field: string change_type = 3;
   */
  changeType = "";

  constructor(data?: PartialMessage<SubspaceAdded>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.SubspaceAdded";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subspace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "plugin_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "change_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubspaceAdded {
    return new SubspaceAdded().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubspaceAdded {
    return new SubspaceAdded().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubspaceAdded {
    return new SubspaceAdded().fromJsonString(jsonString, options);
  }

  static equals(a: SubspaceAdded | PlainMessage<SubspaceAdded> | undefined, b: SubspaceAdded | PlainMessage<SubspaceAdded> | undefined): boolean {
    return proto3.util.equals(SubspaceAdded, a, b);
  }
}

/**
 * @generated from message schema.SubspacesAdded
 */
export class SubspacesAdded extends Message<SubspacesAdded> {
  /**
   * @generated from field: repeated schema.SubspaceAdded subspaces = 1;
   */
  subspaces: SubspaceAdded[] = [];

  constructor(data?: PartialMessage<SubspacesAdded>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.SubspacesAdded";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subspaces", kind: "message", T: SubspaceAdded, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubspacesAdded {
    return new SubspacesAdded().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubspacesAdded {
    return new SubspacesAdded().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubspacesAdded {
    return new SubspacesAdded().fromJsonString(jsonString, options);
  }

  static equals(a: SubspacesAdded | PlainMessage<SubspacesAdded> | undefined, b: SubspacesAdded | PlainMessage<SubspacesAdded> | undefined): boolean {
    return proto3.util.equals(SubspacesAdded, a, b);
  }
}

/**
 * @generated from message schema.SubspaceRemoved
 */
export class SubspaceRemoved extends Message<SubspaceRemoved> {
  /**
   * @generated from field: string subspace = 1;
   */
  subspace = "";

  /**
   * @generated from field: string plugin_address = 2;
   */
  pluginAddress = "";

  /**
   * @generated from field: string change_type = 3;
   */
  changeType = "";

  constructor(data?: PartialMessage<SubspaceRemoved>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.SubspaceRemoved";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subspace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "plugin_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "change_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubspaceRemoved {
    return new SubspaceRemoved().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubspaceRemoved {
    return new SubspaceRemoved().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubspaceRemoved {
    return new SubspaceRemoved().fromJsonString(jsonString, options);
  }

  static equals(a: SubspaceRemoved | PlainMessage<SubspaceRemoved> | undefined, b: SubspaceRemoved | PlainMessage<SubspaceRemoved> | undefined): boolean {
    return proto3.util.equals(SubspaceRemoved, a, b);
  }
}

/**
 * @generated from message schema.SubspacesRemoved
 */
export class SubspacesRemoved extends Message<SubspacesRemoved> {
  /**
   * @generated from field: repeated schema.SubspaceRemoved subspaces = 1;
   */
  subspaces: SubspaceRemoved[] = [];

  constructor(data?: PartialMessage<SubspacesRemoved>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.SubspacesRemoved";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subspaces", kind: "message", T: SubspaceRemoved, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubspacesRemoved {
    return new SubspacesRemoved().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubspacesRemoved {
    return new SubspacesRemoved().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubspacesRemoved {
    return new SubspacesRemoved().fromJsonString(jsonString, options);
  }

  static equals(a: SubspacesRemoved | PlainMessage<SubspacesRemoved> | undefined, b: SubspacesRemoved | PlainMessage<SubspacesRemoved> | undefined): boolean {
    return proto3.util.equals(SubspacesRemoved, a, b);
  }
}

/**
 * *
 * Votes represent a vote on a proposal in a DAO-based space.
 *
 * Currently we use a simple majority voting model, where a proposal requires 51% of the
 * available votes in order to pass. Only editors are allowed to vote on proposals, but editors
 * _and_ members can create them.
 *
 * @generated from message schema.VoteCast
 */
export class VoteCast extends Message<VoteCast> {
  /**
   * @generated from field: string onchain_proposal_id = 1;
   */
  onchainProposalId = "";

  /**
   * @generated from field: string voter = 2;
   */
  voter = "";

  /**
   * @generated from field: uint64 vote_option = 3;
   */
  voteOption = protoInt64.zero;

  /**
   * @generated from field: string plugin_address = 5;
   */
  pluginAddress = "";

  constructor(data?: PartialMessage<VoteCast>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.VoteCast";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "onchain_proposal_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "voter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "vote_option", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "plugin_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VoteCast {
    return new VoteCast().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VoteCast {
    return new VoteCast().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VoteCast {
    return new VoteCast().fromJsonString(jsonString, options);
  }

  static equals(a: VoteCast | PlainMessage<VoteCast> | undefined, b: VoteCast | PlainMessage<VoteCast> | undefined): boolean {
    return proto3.util.equals(VoteCast, a, b);
  }
}

/**
 * @generated from message schema.VotesCast
 */
export class VotesCast extends Message<VotesCast> {
  /**
   * @generated from field: repeated schema.VoteCast votes = 1;
   */
  votes: VoteCast[] = [];

  constructor(data?: PartialMessage<VotesCast>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.VotesCast";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "votes", kind: "message", T: VoteCast, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VotesCast {
    return new VotesCast().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VotesCast {
    return new VotesCast().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VotesCast {
    return new VotesCast().fromJsonString(jsonString, options);
  }

  static equals(a: VotesCast | PlainMessage<VotesCast> | undefined, b: VotesCast | PlainMessage<VotesCast> | undefined): boolean {
    return proto3.util.equals(VotesCast, a, b);
  }
}

/**
 * @generated from message schema.MemberAdded
 */
export class MemberAdded extends Message<MemberAdded> {
  /**
   * @generated from field: string member_address = 1;
   */
  memberAddress = "";

  /**
   * @generated from field: string main_voting_plugin_address = 2;
   */
  mainVotingPluginAddress = "";

  /**
   * @generated from field: string change_type = 3;
   */
  changeType = "";

  constructor(data?: PartialMessage<MemberAdded>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.MemberAdded";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "main_voting_plugin_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "change_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberAdded {
    return new MemberAdded().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberAdded {
    return new MemberAdded().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberAdded {
    return new MemberAdded().fromJsonString(jsonString, options);
  }

  static equals(a: MemberAdded | PlainMessage<MemberAdded> | undefined, b: MemberAdded | PlainMessage<MemberAdded> | undefined): boolean {
    return proto3.util.equals(MemberAdded, a, b);
  }
}

/**
 * @generated from message schema.MembersAdded
 */
export class MembersAdded extends Message<MembersAdded> {
  /**
   * @generated from field: repeated schema.MemberAdded members = 1;
   */
  members: MemberAdded[] = [];

  constructor(data?: PartialMessage<MembersAdded>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.MembersAdded";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "members", kind: "message", T: MemberAdded, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MembersAdded {
    return new MembersAdded().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MembersAdded {
    return new MembersAdded().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MembersAdded {
    return new MembersAdded().fromJsonString(jsonString, options);
  }

  static equals(a: MembersAdded | PlainMessage<MembersAdded> | undefined, b: MembersAdded | PlainMessage<MembersAdded> | undefined): boolean {
    return proto3.util.equals(MembersAdded, a, b);
  }
}

/**
 * @generated from message schema.MemberRemoved
 */
export class MemberRemoved extends Message<MemberRemoved> {
  /**
   * @generated from field: string member_address = 1;
   */
  memberAddress = "";

  /**
   * @generated from field: string main_voting_plugin_address = 2;
   */
  mainVotingPluginAddress = "";

  /**
   * @generated from field: string change_type = 3;
   */
  changeType = "";

  constructor(data?: PartialMessage<MemberRemoved>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.MemberRemoved";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "member_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "main_voting_plugin_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "change_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberRemoved {
    return new MemberRemoved().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberRemoved {
    return new MemberRemoved().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberRemoved {
    return new MemberRemoved().fromJsonString(jsonString, options);
  }

  static equals(a: MemberRemoved | PlainMessage<MemberRemoved> | undefined, b: MemberRemoved | PlainMessage<MemberRemoved> | undefined): boolean {
    return proto3.util.equals(MemberRemoved, a, b);
  }
}

/**
 * @generated from message schema.MembersRemoved
 */
export class MembersRemoved extends Message<MembersRemoved> {
  /**
   * @generated from field: repeated schema.MemberRemoved members = 1;
   */
  members: MemberRemoved[] = [];

  constructor(data?: PartialMessage<MembersRemoved>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.MembersRemoved";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "members", kind: "message", T: MemberRemoved, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MembersRemoved {
    return new MembersRemoved().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MembersRemoved {
    return new MembersRemoved().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MembersRemoved {
    return new MembersRemoved().fromJsonString(jsonString, options);
  }

  static equals(a: MembersRemoved | PlainMessage<MembersRemoved> | undefined, b: MembersRemoved | PlainMessage<MembersRemoved> | undefined): boolean {
    return proto3.util.equals(MembersRemoved, a, b);
  }
}

/**
 * @generated from message schema.EditorAdded
 */
export class EditorAdded extends Message<EditorAdded> {
  /**
   * @generated from field: string editor_address = 1;
   */
  editorAddress = "";

  /**
   * @generated from field: string main_voting_plugin_address = 2;
   */
  mainVotingPluginAddress = "";

  /**
   * @generated from field: string change_type = 3;
   */
  changeType = "";

  constructor(data?: PartialMessage<EditorAdded>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.EditorAdded";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "editor_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "main_voting_plugin_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "change_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EditorAdded {
    return new EditorAdded().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EditorAdded {
    return new EditorAdded().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EditorAdded {
    return new EditorAdded().fromJsonString(jsonString, options);
  }

  static equals(a: EditorAdded | PlainMessage<EditorAdded> | undefined, b: EditorAdded | PlainMessage<EditorAdded> | undefined): boolean {
    return proto3.util.equals(EditorAdded, a, b);
  }
}

/**
 * @generated from message schema.EditorsAdded
 */
export class EditorsAdded extends Message<EditorsAdded> {
  /**
   * @generated from field: repeated schema.EditorAdded editors = 1;
   */
  editors: EditorAdded[] = [];

  constructor(data?: PartialMessage<EditorsAdded>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.EditorsAdded";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "editors", kind: "message", T: EditorAdded, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EditorsAdded {
    return new EditorsAdded().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EditorsAdded {
    return new EditorsAdded().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EditorsAdded {
    return new EditorsAdded().fromJsonString(jsonString, options);
  }

  static equals(a: EditorsAdded | PlainMessage<EditorsAdded> | undefined, b: EditorsAdded | PlainMessage<EditorsAdded> | undefined): boolean {
    return proto3.util.equals(EditorsAdded, a, b);
  }
}

/**
 * @generated from message schema.EditorRemoved
 */
export class EditorRemoved extends Message<EditorRemoved> {
  /**
   * @generated from field: string editor_address = 1;
   */
  editorAddress = "";

  /**
   * @generated from field: string main_voting_plugin_address = 2;
   */
  mainVotingPluginAddress = "";

  /**
   * @generated from field: string change_type = 3;
   */
  changeType = "";

  constructor(data?: PartialMessage<EditorRemoved>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.EditorRemoved";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "editor_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "main_voting_plugin_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "change_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EditorRemoved {
    return new EditorRemoved().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EditorRemoved {
    return new EditorRemoved().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EditorRemoved {
    return new EditorRemoved().fromJsonString(jsonString, options);
  }

  static equals(a: EditorRemoved | PlainMessage<EditorRemoved> | undefined, b: EditorRemoved | PlainMessage<EditorRemoved> | undefined): boolean {
    return proto3.util.equals(EditorRemoved, a, b);
  }
}

/**
 * @generated from message schema.EditorsRemoved
 */
export class EditorsRemoved extends Message<EditorsRemoved> {
  /**
   * @generated from field: repeated schema.EditorRemoved editors = 1;
   */
  editors: EditorRemoved[] = [];

  constructor(data?: PartialMessage<EditorsRemoved>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.EditorsRemoved";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "editors", kind: "message", T: EditorRemoved, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EditorsRemoved {
    return new EditorsRemoved().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EditorsRemoved {
    return new EditorsRemoved().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EditorsRemoved {
    return new EditorsRemoved().fromJsonString(jsonString, options);
  }

  static equals(a: EditorsRemoved | PlainMessage<EditorsRemoved> | undefined, b: EditorsRemoved | PlainMessage<EditorsRemoved> | undefined): boolean {
    return proto3.util.equals(EditorsRemoved, a, b);
  }
}

/**
 * @generated from message schema.GeoOutput
 */
export class GeoOutput extends Message<GeoOutput> {
  /**
   * @generated from field: repeated schema.GeoProfileRegistered profiles_registered = 1;
   */
  profilesRegistered: GeoProfileRegistered[] = [];

  /**
   * @generated from field: repeated schema.GeoSpaceCreated spaces_created = 2;
   */
  spacesCreated: GeoSpaceCreated[] = [];

  /**
   * @generated from field: repeated schema.GeoGovernancePluginCreated governance_plugins_created = 3;
   */
  governancePluginsCreated: GeoGovernancePluginCreated[] = [];

  /**
   * @generated from field: repeated schema.InitialEditorAdded initial_editors_added = 4;
   */
  initialEditorsAdded: InitialEditorAdded[] = [];

  /**
   * @generated from field: repeated schema.ProposalCreated proposals_created = 5;
   */
  proposalsCreated: ProposalCreated[] = [];

  /**
   * @generated from field: repeated schema.VoteCast votes_cast = 6;
   */
  votesCast: VoteCast[] = [];

  /**
   * @generated from field: repeated schema.ProposalProcessed proposals_processed = 7;
   */
  proposalsProcessed: ProposalProcessed[] = [];

  /**
   * @generated from field: repeated schema.SuccessorSpaceCreated successor_spaces_created = 8;
   */
  successorSpacesCreated: SuccessorSpaceCreated[] = [];

  /**
   * @generated from field: repeated schema.SubspaceAdded subspaces_added = 9;
   */
  subspacesAdded: SubspaceAdded[] = [];

  /**
   * @generated from field: repeated schema.SubspaceRemoved subspaces_removed = 10;
   */
  subspacesRemoved: SubspaceRemoved[] = [];

  /**
   * @generated from field: repeated schema.ProposalExecuted executed_proposals = 11;
   */
  executedProposals: ProposalExecuted[] = [];

  /**
   * @generated from field: repeated schema.MemberAdded members_added = 12;
   */
  membersAdded: MemberAdded[] = [];

  /**
   * @generated from field: repeated schema.EditorAdded editors_added = 13;
   */
  editorsAdded: EditorAdded[] = [];

  /**
   * @generated from field: repeated schema.GeoPersonalSpaceAdminPluginCreated personal_plugins_created = 14;
   */
  personalPluginsCreated: GeoPersonalSpaceAdminPluginCreated[] = [];

  constructor(data?: PartialMessage<GeoOutput>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "schema.GeoOutput";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "profiles_registered", kind: "message", T: GeoProfileRegistered, repeated: true },
    { no: 2, name: "spaces_created", kind: "message", T: GeoSpaceCreated, repeated: true },
    { no: 3, name: "governance_plugins_created", kind: "message", T: GeoGovernancePluginCreated, repeated: true },
    { no: 4, name: "initial_editors_added", kind: "message", T: InitialEditorAdded, repeated: true },
    { no: 5, name: "proposals_created", kind: "message", T: ProposalCreated, repeated: true },
    { no: 6, name: "votes_cast", kind: "message", T: VoteCast, repeated: true },
    { no: 7, name: "proposals_processed", kind: "message", T: ProposalProcessed, repeated: true },
    { no: 8, name: "successor_spaces_created", kind: "message", T: SuccessorSpaceCreated, repeated: true },
    { no: 9, name: "subspaces_added", kind: "message", T: SubspaceAdded, repeated: true },
    { no: 10, name: "subspaces_removed", kind: "message", T: SubspaceRemoved, repeated: true },
    { no: 11, name: "executed_proposals", kind: "message", T: ProposalExecuted, repeated: true },
    { no: 12, name: "members_added", kind: "message", T: MemberAdded, repeated: true },
    { no: 13, name: "editors_added", kind: "message", T: EditorAdded, repeated: true },
    { no: 14, name: "personal_plugins_created", kind: "message", T: GeoPersonalSpaceAdminPluginCreated, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoOutput {
    return new GeoOutput().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoOutput {
    return new GeoOutput().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoOutput {
    return new GeoOutput().fromJsonString(jsonString, options);
  }

  static equals(a: GeoOutput | PlainMessage<GeoOutput> | undefined, b: GeoOutput | PlainMessage<GeoOutput> | undefined): boolean {
    return proto3.util.equals(GeoOutput, a, b);
  }
}

